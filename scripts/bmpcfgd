#!/usr/bin/env python3
'''
bmpcfgd
Daemon which monitors bmp relevant table enablement from CONFIG_DB, and reset BMP states
'''

import os
import sys
import subprocess
import syslog
import signal
from shutil import copy2
from datetime import datetime
from sonic_py_common import device_info
from sonic_py_common.general import check_output_pipe
from swsscommon.swsscommon import ConfigDBConnector, DBConnector, Table
from swsscommon import swsscommon

CFG_DB = "CONFIG_DB"
STATE_DB = "STATE_DB"


class BMPCfg(object):
    def __init__(self, state_db_conn):
        self.bgp_neighbor_table  = False
        self.bgp_rib_in_table  = False
        self.bgp_rib_out_table  = False
        self.state_db_conn = state_db_conn


    def load(self, data={}):
        common_config = data.get('table', {})
        if not common_config:
            syslog.syslog(syslog.LOG_INFO, f'BMPCfg: skipped the bmp config, the BMP setting is empty.')
            return

        self.bgp_neighbor_table = is_true(common_config.get('bgp_neighbor_table', 'false'))
        self.bgp_rib_in_table = is_true(common_config.get('bgp_rib_in_table', 'false'))
        self.bgp_rib_out_table = is_true(common_config.get('bgp_rib_out_table', 'false'))
        syslog.syslog(syslog.LOG_INFO, f'BMPCfg: update : {self.bgp_neighbor_table}, {self.bgp_rib_in_table}, {self.bgp_rib_out_table}.')

        # reset bmp table state once config is changed.
        self.stop_bmp()
        self.reset_bmp_table()
        self.start_bmp()

    def cfg_handler(self, data):
        self.load(data)
  
    def stop_bmp(self):
        syslog.syslog(syslog.LOG_INFO, 'stop bmp daemon')
        subprocess.call(["service", "openbmpd", "stop"])

    def reset_bmp_table(self):
        syslog.syslog(syslog.LOG_INFO, 'Reset bmp table from state_db')
        self.state_db_conn.delete_all_by_pattern('STATE_DB', 'BGP_NEIGHBOR*')
        self.state_db_conn.delete_all_by_pattern('STATE_DB', 'BGP_RIB_IN_TABLE*')
        self.state_db_conn.delete_all_by_pattern('STATE_DB', 'BGP_RIB_OUT_TABLE*')

    def start_bmp(self):
        syslog.syslog(syslog.LOG_INFO, 'start bmp daemon')
        subprocess.call(["service", "openbmpd", "start"])


class BMPCfgDaemon:
    def __init__(self):
        self.state_db_conn = DBConnector(STATE_DB, 0)
        self.config_db = ConfigDBConnector()
        self.config_db.connect(wait_for_init=True, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'ConfigDB connect success')
        self.bmpcfg = BMPCfg(self.state_db_conn)

    def bmp_handler(self, key, op, data):
        syslog.syslog(syslog.LOG_INFO, 'BMP table handler...')
        data = self.config_db.get_table("BMP")
        self.bmpcfg.cfg_handler(data)

    def register_callbacks(self):

        def make_callback(func):
            def callback(table, key, data):
                if data is None:
                    op = "DEL"
                    data = {}
                else:
                    op = "SET"
                return func(key, op, data)
            return callback

        self.config_db.subscribe('BMP', make_callback(self.bmp_handler))

    def start(self):
        self.config_db.listen(init_data_handler=self.load)

def signal_handler(sig, frame):
    if sig == signal.SIGHUP:
        syslog.syslog(syslog.LOG_INFO, "bmpcfgd: signal 'SIGHUP' is caught and ignoring..")
    elif sig == signal.SIGINT:
        syslog.syslog(syslog.LOG_INFO, "bmpcfgd: signal 'SIGINT' is caught and exiting...")
        sys.exit(128 + sig)
    elif sig == signal.SIGTERM:
        syslog.syslog(syslog.LOG_INFO, "bmpcfgd: signal 'SIGTERM' is caught and exiting...")
        sys.exit(128 + sig)
    else:
        syslog.syslog(syslog.LOG_INFO, "bmpcfgd: invalid signal - ignoring..")

def main():
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGHUP, signal_handler)
    daemon = BMPCfgDaemon()
    daemon.register_callbacks()
    daemon.start()

if __name__ == "__main__":
    main()
