#!/usr/bin/env python3
"""
Console Monitor Service

Unified Console Monitor service that automatically runs in DCE or DTE mode based on CONFIG_DB configuration.

DCE (Console Server side):
- Creates PTY proxy for each serial port
- Filters heartbeat frames, updates link state to STATE_DB

DTE (SONiC Switch side):
- Periodically sends heartbeat frames
- Listens for CONFIG_DB configuration changes

Usage:
    console-monitor-dce              # Start DCE service
    console-monitor-dte [tty] [baud] # Start DTE service
"""

import os
import re
import sys
import time
import fcntl
import termios
import tty
import signal
import argparse
import logging
import threading
import select
from dataclasses import dataclass
from enum import IntEnum
from typing import Optional, Callable, Dict

from swsscommon.swsscommon import (
    DBConnector,
    Table,
    ConfigDBConnector,
)

# ============================================================
# Logging Configuration
# ============================================================

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
log = logging.getLogger("console-monitor")


# ============================================================
# Global Constants
# ============================================================

# Timeout configuration
HEARTBEAT_INTERVAL = 5.0      # DTE heartbeat send interval (seconds)
HEARTBEAT_TIMEOUT = 15.0      # DCE heartbeat timeout (seconds)

# Baud rate mapping
BAUD_MAP = {
    1200: termios.B1200,
    2400: termios.B2400,
    4800: termios.B4800,
    9600: termios.B9600,
    19200: termios.B19200,
    38400: termios.B38400,
    57600: termios.B57600,
    115200: termios.B115200,
}

# Redis table names
CONSOLE_PORT_TABLE = "CONSOLE_PORT"
CONSOLE_SWITCH_TABLE = "CONSOLE_SWITCH"

# Default baud rate
DEFAULT_BAUD = 9600

# Kernel command line path
PROC_CMDLINE = "/proc/cmdline"


# ============================================================
# Frame Protocol Constants and Classes
# ============================================================

class SpecialChar(IntEnum):
    """Special character definitions"""
    SOF = 0x05  # Start of Frame
    EOF = 0x00  # End of Frame
    DLE = 0x10  # Data Link Escape


# Set of escapable characters
ESCAPABLE_CHARS = frozenset({SpecialChar.SOF, SpecialChar.EOF, SpecialChar.DLE})


class FrameType(IntEnum):
    """Frame type definitions"""
    HEARTBEAT = 0x01


# Protocol version
PROTOCOL_VERSION = 0x01

# SOF/EOF length
SOF_LEN = 3
EOF_LEN = 3

# Buffer size limit
MAX_FRAME_BUFFER_SIZE = 64

# SOF/EOF sequences
SOF_SEQUENCE = bytes([SpecialChar.SOF] * SOF_LEN)
EOF_SEQUENCE = bytes([SpecialChar.EOF] * EOF_LEN)

# Exit codes
EXIT_SUCCESS = 0
EXIT_SERVICE_START_FAILED = 1
EXIT_SERIAL_CONFIG_ERROR = 2
EXIT_INVALID_MODE = 3


def log_binary_data(data: bytes, direction: str) -> None:
    """
    Output data in binary and readable form to terminal
    
    Args:
        data: Byte data to output
        direction: Data flow direction (e.g., "Serial→PTY", "PTY→Serial")
    """ 
    hex_str = data.hex(' ', 1)  # Space-separated bytes
    # Replace non-printable characters with <HEX>
    readable = ''.join(chr(b) if 32 <= b < 127 else f"<0x{b:02x}>" for b in data)
    log.debug(f"[{direction} ({len(data)} bytes):\n  HEX: {hex_str}\n  ASCII: {readable}\n")



def crc16_modbus(data: bytes) -> int:
    """CRC-16/MODBUS algorithm"""
    crc = 0xFFFF
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 0x0001:
                crc = (crc >> 1) ^ 0xA001
            else:
                crc >>= 1
    return crc


def escape_data(data: bytes) -> bytes:
    """Escape data"""
    result = bytearray()
    for byte in data:
        if byte in ESCAPABLE_CHARS:
            result.append(SpecialChar.DLE)
        result.append(byte)
    return bytes(result)


def unescape_data(data: bytes) -> bytes:
    """Unescape data"""
    result = bytearray()
    i = 0
    while i < len(data):
        if data[i] == SpecialChar.DLE and i + 1 < len(data) and data[i + 1] in ESCAPABLE_CHARS:
            result.append(data[i + 1])
            i += 2
        else:
            result.append(data[i])
            i += 1
    return bytes(result)


@dataclass
class Frame:
    """Frame data structure"""
    version: int = PROTOCOL_VERSION
    seq: int = 0
    flag: int = 0x00
    frame_type: int = FrameType.HEARTBEAT
    payload: bytes = b""
    
    def build(self) -> bytes:
        """Build complete frame binary sequence"""
        content = bytes([
            self.version,
            self.seq & 0xFF,
            self.flag,
            self.frame_type,
            len(self.payload),
        ]) + self.payload
        
        crc = crc16_modbus(content)
        crc_bytes = bytes([crc >> 8, crc & 0xFF])
        
        content_with_crc = content + crc_bytes
        escaped_content = escape_data(content_with_crc)
        
        return SOF_SEQUENCE + escaped_content + EOF_SEQUENCE
    
    @classmethod
    def parse(cls, buffer: bytes) -> Optional['Frame']:
        """Parse frame from buffer"""
        unescaped = unescape_data(buffer)
        
        if len(unescaped) < 7:
            return None
        
        content = unescaped[:-2]
        crc_bytes = unescaped[-2:]
        
        expected_crc = crc16_modbus(content)
        received_crc = (crc_bytes[0] << 8) | crc_bytes[1]
        
        if expected_crc != received_crc:
            return None
        
        if len(content) < 5:
            return None
        
        version = content[0]
        seq = content[1]
        flag = content[2]
        frame_type = content[3]
        length = content[4]
        payload = content[5:5 + length] if length > 0 else b""
        
        return cls(
            version=version,
            seq=seq,
            flag=flag,
            frame_type=frame_type,
            payload=payload,
        )
    
    @classmethod
    def create_heartbeat(cls, seq: int = 0) -> 'Frame':
        """Create heartbeat frame"""
        return cls(
            version=PROTOCOL_VERSION,
            seq=seq,
            flag=0x00,
            frame_type=FrameType.HEARTBEAT,
            payload=b"",
        )
    
    def is_heartbeat(self) -> bool:
        """Check if this is a heartbeat frame"""
        return self.frame_type == FrameType.HEARTBEAT


# Callback function types
FrameCallback = Callable[[Frame], None]
UserDataCallback = Callable[[bytes], None]


class FrameFilter:
    """Frame filter: identifies frames and user data from byte stream"""
    
    def __init__(
        self,
        on_frame: Optional[FrameCallback] = None,
        on_user_data: Optional[UserDataCallback] = None,
    ):
        self._on_frame = on_frame
        self._on_user_data = on_user_data
        self._buffer = bytearray()
        self._escape_next = False
        self._in_frame = False
    
    def process(self, data: bytes) -> None:
        """Process input byte stream"""

        log_binary_data(data, "Received")

        for byte in data:
            if self._escape_next:

                self._buffer.append(byte)
                self._escape_next = False
                if len(self._buffer) >= MAX_FRAME_BUFFER_SIZE:
                    self._flush_buffer()

            elif byte == SpecialChar.DLE:

                self._buffer.append(byte)
                if self.in_frame:
                    self._escape_next = True

            elif byte == SpecialChar.SOF:

                if not self._in_frame:
                    self._flush_as_user_data()
                else:
                    self._discard_buffer()
                self._in_frame = True

            elif byte == SpecialChar.EOF:

                self._try_parse_frame()
                self._in_frame = False

            else:
                
                self._buffer.append(byte)
                if len(self._buffer) >= MAX_FRAME_BUFFER_SIZE:
                    self._flush_buffer()
    
    def on_timeout(self) -> None:
        """Timeout callback"""
        if not self._in_frame:
            self._flush_as_user_data()
        else:
            self._discard_buffer()
        self._in_frame = False
    
    def flush(self) -> bytes:
        """Flush buffer and return remaining data"""
        result = bytes(self._buffer)
        self._buffer.clear()
        self._escape_next = False
        self._in_frame = False
        return result
    
    def has_pending_data(self) -> bool:
        """Check if there is pending data"""
        return len(self._buffer) > 0
    
    @property
    def in_frame(self) -> bool:
        """Check if currently inside a frame"""
        return self._in_frame
    
    def _flush_as_user_data(self) -> None:
        """Send buffer as user data"""
        if self._buffer and self._on_user_data:
            log_binary_data(self._buffer, 'User Data')
            self._on_user_data(bytes(self._buffer))
        self._buffer.clear()
        self._escape_next = False
    
    def _discard_buffer(self) -> None:
        """Discard buffer"""
        self._buffer.clear()
        self._escape_next = False
    
    def _flush_buffer(self) -> None:
        """Handle buffer overflow based on whether inside a frame"""
        if not self._in_frame:
            self._flush_as_user_data()
        else:
            self._discard_buffer()
        self._in_frame = False
    
    def _try_parse_frame(self) -> None:
        """Try to parse buffer as frame"""
        if not self._buffer:
            self._escape_next = False
            return

        log_binary_data(self._buffer, 'Frame Data')
        
        frame = Frame.parse(bytes(self._buffer))
        self._buffer.clear()
        self._escape_next = False
        
        if frame is not None and self._on_frame:
            # Parse successful, invoke frame callback
            self._on_frame(frame)

        # Parse failed, this should not happen under normal circumstances
        # Because if data between SOF...EOF is not a valid frame,
        # it means the data is corrupted, just discard it



# ============================================================
# Utility Functions
# ============================================================

def get_pty_symlink_prefix() -> str:
    """Read PTY symlink prefix from udevprefix.conf"""
    try:
        from sonic_py_common import device_info
        platform_path, _ = device_info.get_paths_to_platform_and_hwsku_dirs()
        config_file = os.path.join(platform_path, "udevprefix.conf")
        
        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                prefix = f.readline().rstrip()
                return f"/dev/V{prefix}"
    except Exception as e:
        log.warning(f"Failed to read udevprefix.conf: {e}")
    
    return "/dev/VC0-"


def set_nonblocking(fd: int) -> None:
    """Set file descriptor to non-blocking mode"""
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)


def configure_serial(fd: int, baud: int) -> None:
    """Configure serial port parameters"""
    attrs = termios.tcgetattr(fd)
    attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK |
                  termios.ISTRIP | termios.INLCR | termios.IGNCR |
                  termios.ICRNL | termios.IXON)
    attrs[1] &= ~termios.OPOST
    attrs[2] &= ~(termios.CSIZE | termios.PARENB)
    attrs[2] |= (termios.CS8 | termios.CREAD | termios.CLOCAL)
    attrs[3] &= ~(termios.ECHO | termios.ECHONL | termios.ICANON |
                  termios.ISIG | termios.IEXTEN)
    attrs[6][termios.VMIN] = 0
    attrs[6][termios.VTIME] = 0
    speed = BAUD_MAP.get(baud, termios.B9600)
    attrs[4] = attrs[5] = speed
    termios.tcsetattr(fd, termios.TCSANOW, attrs)
    termios.tcflush(fd, termios.TCIOFLUSH)


def configure_pty(fd: int) -> None:
    """Configure PTY in raw mode"""
    tty.setraw(fd, when=termios.TCSANOW)
    attrs = termios.tcgetattr(fd)
    attrs[3] &= ~(termios.ECHO | termios.ECHONL)
    termios.tcsetattr(fd, termios.TCSANOW, attrs)


def parse_proc_cmdline() -> tuple[str, int]:
    """
    Parse serial configuration from /proc/cmdline
    
    Returns:
        (tty_name, baud)
    
    Raises:
        ValueError: No valid console parameter found
    """
    try:
        with open(PROC_CMDLINE, 'r') as f:
            cmdline = f.read().strip()
    except Exception as e:
        raise ValueError(f"Failed to read {PROC_CMDLINE}: {e}")
    
    pattern = r'console=([a-zA-Z0-9]+)(?:,([0-9]+))?'
    matches = re.findall(pattern, cmdline)
    
    if not matches:
        raise ValueError(f"No console= parameter found in {PROC_CMDLINE}")
    
    tty_name, baud_str = matches[-1]
    baud = int(baud_str) if baud_str else DEFAULT_BAUD
    
    log.info(f"Parsed from /proc/cmdline: tty={tty_name}, baud={baud}")
    return (tty_name, baud)


# ============================================================
# DCE Serial Proxy
# ============================================================

class SerialProxy:
    """
    Serial proxy: creates PTY and forwards serial data
    
    Uses select for multiplexing, runs in a separate thread.
    Each proxy has its own Redis connection to avoid multi-thread contention.
    """
    
    def __init__(self, link_id: str, device: str, baud: int, pty_symlink_prefix: str):
        self.link_id = link_id
        self.device = device
        self.baud = baud
        self.pty_symlink_prefix = pty_symlink_prefix
        
        # Each proxy creates its own Redis connection to avoid multi-thread contention
        self.state_db: Optional[DBConnector] = None
        self.state_table: Optional[Table] = None
        
        self.ser_fd: int = -1
        self.pty_master: int = -1
        self.pty_slave: int = -1
        self.pty_name: str = ""
        self.pty_symlink: str = ""
        self.filter: Optional[FrameFilter] = None
        self.running: bool = False
        
        # State tracking
        self._current_oper_state: Optional[str] = None
        self._last_heartbeat_time: float = 0.0
        self._last_data_activity: float = 0.0
        self._last_serial_data_time: float = 0.0  # For filter timeout detection
        
        # Thread
        self._thread: Optional[threading.Thread] = None
        
        # Pipe for waking up select
        self._wake_r: int = -1
        self._wake_w: int = -1
    
    def start(self) -> bool:
        """Start proxy"""
        try:
            # Create independent Redis connection (one per proxy to avoid multi-thread contention)
            self.state_db = DBConnector("STATE_DB", 0)
            self.state_table = Table(self.state_db, CONSOLE_PORT_TABLE)
            
            # Create wake-up pipe
            self._wake_r, self._wake_w = os.pipe()
            set_nonblocking(self._wake_r)
            
            # Create PTY
            self.pty_master, self.pty_slave = os.openpty()
            self.pty_name = os.ttyname(self.pty_slave)
            
            # Open serial port
            self.ser_fd = os.open(self.device, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)
            
            # Configure serial port and PTY
            configure_serial(self.ser_fd, self.baud)
            configure_pty(self.pty_master)
            configure_pty(self.pty_slave)
            set_nonblocking(self.pty_master)
            set_nonblocking(self.ser_fd)
            
            # Create frame filter
            self.filter = FrameFilter(
                on_frame=self._on_frame_received,
                on_user_data=self._on_user_data_received,
            )
            
            # Create symlink
            self._create_symlink()
            
            self.running = True
            self._last_heartbeat_time = time.monotonic()
            self._last_data_activity = time.monotonic()
            
            # Start worker thread
            self._thread = threading.Thread(target=self._run_loop, daemon=True)
            self._thread.start()
            
            log.info(f"[{self.link_id}] Started: {self.device} -> {self.pty_name} ({self.pty_symlink})")
            return True
            
        except Exception as e:
            log.error(f"[{self.link_id}] Failed to start: {e}")
            self.stop()
            return False
    
    def stop(self) -> None:
        """Stop proxy"""
        self.running = False
        
        # Wake up select loop
        if self._wake_w >= 0:
            try:
                os.write(self._wake_w, b'x')
            except:
                pass
        
        # Wait for thread to finish
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=2.0)
        
        # Cleanup STATE_DB state
        self._cleanup_state()
        
        # Remove symlink
        self._remove_symlink()
        
        # Flush remaining data
        if self.filter and self.pty_master >= 0:
            remaining = self.filter.flush()
            if remaining:
                try:
                    os.write(self.pty_master, remaining)
                except:
                    pass
        
        # Close file descriptors
        for fd in (self._wake_r, self._wake_w, self.ser_fd, self.pty_master, self.pty_slave):
            if fd >= 0:
                try:
                    os.close(fd)
                except:
                    pass
        
        self._wake_r = self._wake_w = -1
        self.ser_fd = self.pty_master = self.pty_slave = -1
        
        log.info(f"[{self.link_id}] Stopped")
    
    def _run_loop(self) -> None:
        """Worker thread main loop"""
        filter_timeout = self._calculate_filter_timeout(self.baud)

        while self.running:
            try:
                # Calculate select timeout
                now = time.monotonic()
                time_since_heartbeat = now - self._last_heartbeat_time
                select_timeout = max(0.1, HEARTBEAT_TIMEOUT - time_since_heartbeat)

                # If filter has pending data, consider filter timeout
                if self.filter and self.filter.has_pending_data():
                    time_since_serial = now - self._last_serial_data_time
                    remaining_filter_timeout = filter_timeout - time_since_serial
                    if remaining_filter_timeout > 0:
                        select_timeout = min(select_timeout, remaining_filter_timeout)
                    else:
                        # Filter timeout reached, process immediately
                        select_timeout = 0

                # Use select to monitor serial port, PTY, and wake-up pipe
                readable, _, _ = select.select(
                    [self.ser_fd, self.pty_master, self._wake_r],
                    [], [],
                    select_timeout
                )

                if not self.running:
                    break

                serial_data_received = False
                for fd in readable:
                    if fd == self.ser_fd:
                        self._on_serial_read()
                        serial_data_received = True
                    elif fd == self.pty_master:
                        self._on_pty_read()
                    elif fd == self._wake_r:
                        # Clear wake-up pipe
                        try:
                            os.read(self._wake_r, 1024)
                        except:
                            pass

                # Check heartbeat timeout
                self._check_heartbeat_timeout()

                # Check filter timeout: only trigger when no new serial data received and timeout reached
                if self.filter and self.filter.has_pending_data() and not serial_data_received:
                    now = time.monotonic()
                    if now - self._last_serial_data_time >= filter_timeout:
                        self.filter.on_timeout()

            except Exception as e:
                if self.running:
                    log.error(f"[{self.link_id}] Loop error: {e}")
                    time.sleep(0.1)
    
    def _on_serial_read(self) -> None:
        """Serial data read callback"""
        if not self.running or not self.filter:
            return
        try:
            data = os.read(self.ser_fd, 4096)
            if data:
                now = time.monotonic()
                self._last_data_activity = now
                self._last_serial_data_time = now
                self.filter.process(data)
        except (BlockingIOError, OSError):
            pass
    
    def _on_pty_read(self) -> None:
        """PTY data read callback"""
        if not self.running:
            return
        try:
            data = os.read(self.pty_master, 4096)
            if data:
                os.write(self.ser_fd, data)
        except (BlockingIOError, OSError):
            pass
    
    def _on_frame_received(self, frame: Frame) -> None:
        """Frame received callback"""
        if frame.is_heartbeat():
            self._last_heartbeat_time = time.monotonic()
            self._update_state("Up")
            log.debug(f"[{self.link_id}] Heartbeat received (seq={frame.seq})")
        else:
            log.warning(f"[{self.link_id}] Unknown frame type: {frame.frame_type}")
    
    def _on_user_data_received(self, data: bytes) -> None:
        """User data callback"""
        if self.pty_master >= 0:
            try:
                os.write(self.pty_master, data)
            except OSError:
                pass
    
    def _check_heartbeat_timeout(self) -> None:
        """Check heartbeat timeout"""
        now = time.monotonic()
        time_since_heartbeat = now - self._last_heartbeat_time
        
        if time_since_heartbeat >= HEARTBEAT_TIMEOUT:
            # Check if there is data activity
            time_since_data = now - self._last_data_activity
            if time_since_data < HEARTBEAT_TIMEOUT:
                # Data activity detected, reset heartbeat time and continue waiting
                log.debug(f"[{self.link_id}] Heartbeat timeout but data activity detected")
                self._last_heartbeat_time = now
                return
            
            # No heartbeat and no data activity, cannot determine failure cause (link/system/software layer)
            self._update_state("Unknown")
            self._last_heartbeat_time = now  # Reset to avoid continuous triggering
    
    def _update_state(self, oper_state: str) -> None:
        """Update Redis state (only when state changes)"""
        if oper_state == self._current_oper_state:
            return
        
        self._current_oper_state = oper_state
        timestamp = str(int(time.time()))
        
        try:
            self.state_table.set(
                self.link_id,
                [("oper_state", oper_state), ("last_state_change", timestamp)]
            )
            log.info(f"[{self.link_id}] State: {oper_state}")
        except Exception as e:
            log.error(f"[{self.link_id}] Failed to update state: {e}")
    
    def _cleanup_state(self) -> None:
        """Cleanup STATE_DB state"""
        try:
            # Only delete fields managed by console-monitor
            self.state_table.hdel(self.link_id, "oper_state")
            self.state_table.hdel(self.link_id, "last_state_change")
            log.info(f"[{self.link_id}] STATE_DB cleaned up")
        except Exception as e:
            log.error(f"[{self.link_id}] Failed to cleanup STATE_DB: {e}")
    
    def _create_symlink(self) -> None:
        """Create PTY symlink"""
        self.pty_symlink = f"{self.pty_symlink_prefix}{self.link_id}"
        try:
            if os.path.islink(self.pty_symlink) or os.path.exists(self.pty_symlink):
                os.unlink(self.pty_symlink)
            os.symlink(self.pty_name, self.pty_symlink)
            log.info(f"[{self.link_id}] Symlink: {self.pty_symlink} -> {self.pty_name}")
        except Exception as e:
            log.error(f"[{self.link_id}] Failed to create symlink: {e}")
            self.pty_symlink = ""
    
    def _remove_symlink(self) -> None:
        """Remove PTY symlink"""
        if self.pty_symlink:
            try:
                if os.path.islink(self.pty_symlink):
                    os.unlink(self.pty_symlink)
                    log.info(f"[{self.link_id}] Symlink removed: {self.pty_symlink}")
            except Exception as e:
                log.error(f"[{self.link_id}] Failed to remove symlink: {e}")
            self.pty_symlink = ""
    
    @staticmethod
    def _calculate_filter_timeout(baud: int, multiplier: int = 3) -> float:
        """Calculate frame filter timeout based on baud rate"""
        char_time = 10.0 / baud
        return char_time * MAX_FRAME_BUFFER_SIZE * multiplier



# ============================================================
# DCE Service
# ============================================================

class DCEService:
    """
    DCE side service: manages multiple serial proxies
    
    Uses ConfigDBConnector's subscribe/listen pattern to monitor CONFIG_DB changes,
    following SONiC daemon conventions.
    Each SerialProxy has its own Redis connection to avoid multi-thread contention.
    """
    
    def __init__(self):
        self.config_db: Optional[ConfigDBConnector] = None
        
        self.proxies: Dict[str, SerialProxy] = {}
        self.running: bool = False
        self.pty_symlink_prefix: str = ""
    
    def start(self) -> bool:
        """Start service"""
        try:
            # Connect to CONFIG_DB (using ConfigDBConnector)
            self.config_db = ConfigDBConnector()
            self.config_db.connect(wait_for_init=True, retry_on=True)
            log.info("ConfigDB connected")
            
            # Read PTY symlink prefix
            self.pty_symlink_prefix = get_pty_symlink_prefix()
            log.info(f"PTY symlink prefix: {self.pty_symlink_prefix}")
            
            self.running = True
            log.info("DCE service initialized")
            return True
            
        except Exception as e:
            log.error(f"Failed to start DCE service: {e}")
            return False
    
    def register_callbacks(self) -> None:
        """Register configuration change callbacks"""
        
        def make_callback(func):
            """Create callback wrapper compatible with ConfigDBConnector format"""
            def callback(table, key, data):
                if data is None:
                    op = "DEL"
                    data = {}
                else:
                    op = "SET"
                return func(key, op, data)
            return callback
        
        # Subscribe to CONSOLE_PORT table changes
        self.config_db.subscribe(CONSOLE_PORT_TABLE, 
                                  make_callback(self.console_port_handler))
        
        # Subscribe to CONSOLE_SWITCH table changes (for checking feature toggle)
        self.config_db.subscribe(CONSOLE_SWITCH_TABLE,
                                  make_callback(self.console_switch_handler))
        
        log.info("Callbacks registered")
    
    def run(self) -> None:
        """Main loop: use ConfigDBConnector.listen() to monitor configuration changes"""
        try:
            # listen() blocks and invokes registered callbacks when configuration changes
            # init_data_handler is called when listen starts, with initial data from all subscribed tables
            self.config_db.listen(init_data_handler=self._load_initial_config)
        except KeyboardInterrupt:
            log.info("Received keyboard interrupt")
        except Exception as e:
            if self.running:
                log.error(f"DCE listen error: {e}")
    
    def stop(self) -> None:
        """Stop service"""
        self.running = False
        
        # Stop all proxies
        for proxy in self.proxies.values():
            proxy.stop()
        self.proxies.clear()
        
        log.info("DCE service stopped")
    
    def _load_initial_config(self, init_data: dict) -> None:
        """
        Load initial configuration
        
        Args:
            init_data: Dictionary containing initial data from all subscribed tables
                       Format: {table_name: {key: {field: value, ...}, ...}, ...}
        """
        log.info(f"Loading initial config: {list(init_data.keys())}")
        
        # Perform initial sync
        self._sync()
    
    def console_port_handler(self, key: str, op: str, data: dict) -> None:
        """
        CONSOLE_PORT table change handler
        
        Args:
            key: Table entry key (e.g., "1", "2" port numbers)
            op: Operation type "SET" or "DEL"
            data: Table entry data
        """
        log.info(f"CONSOLE_PORT change: key={key}, op={op}, data={data}")
        self._sync()
    
    def console_switch_handler(self, key: str, op: str, data: dict) -> None:
        """
        CONSOLE_SWITCH table change handler
        
        Args:
            key: Table entry key
            op: Operation type "SET" or "DEL"
            data: Table entry data
        """
        log.info(f"CONSOLE_SWITCH change: key={key}, op={op}, data={data}")
        self._sync()
    
    def _check_feature_enabled(self) -> bool:
        """Check if console switch feature is enabled"""
        try:
            entry = self.config_db.get_entry(CONSOLE_SWITCH_TABLE, "console_mgmt")
            if entry:
                enabled = entry.get("enabled", "")
                if enabled == "yes":
                    return True
            log.warning("Console switch feature is disabled")
            return False
        except Exception as e:
            log.error(f"Failed to check feature status: {e}")
            return False
    
    def _get_all_configs(self) -> Dict[str, dict]:
        """Get all serial port configurations"""
        configs = {}
        try:
            table_data = self.config_db.get_table(CONSOLE_PORT_TABLE)
            for key, entry in table_data.items():
                # Key returned by ConfigDBConnector may be a tuple
                key_str = str(key) if not isinstance(key, str) else key
                configs[key_str] = {
                    "baud": int(entry.get("baud_rate", 9600)),
                    "device": f"/dev/C0-{key_str}",
                }
        except Exception as e:
            log.error(f"Failed to get configs: {e}")
        return configs
    
    def _sync(self) -> None:
        """Sync configuration and proxies"""
        # Check if feature is enabled
        if not self._check_feature_enabled():
            # Feature not enabled, stop all proxies
            if self.proxies:
                log.info("Feature disabled, stopping all proxies")
                for proxy in self.proxies.values():
                    proxy.stop()
                self.proxies.clear()
            return
        
        # Get configuration
        redis_configs = self._get_all_configs()
        redis_ids = set(redis_configs.keys())
        current_ids = set(self.proxies.keys())
        
        # Remove proxies not in configuration
        for link_id in current_ids - redis_ids:
            self.proxies[link_id].stop()
            del self.proxies[link_id]
        
        # Add new proxies
        for link_id in redis_ids - current_ids:
            cfg = redis_configs[link_id]
            proxy = SerialProxy(
                link_id, cfg["device"], cfg["baud"], self.pty_symlink_prefix
            )
            if proxy.start():
                self.proxies[link_id] = proxy
        
        # Update proxies with changed configuration
        for link_id in redis_ids & current_ids:
            cfg = redis_configs[link_id]
            proxy = self.proxies[link_id]
            if proxy.baud != cfg["baud"]:
                proxy.stop()
                new_proxy = SerialProxy(
                    link_id, cfg["device"], cfg["baud"], self.pty_symlink_prefix
                )
                if new_proxy.start():
                    self.proxies[link_id] = new_proxy
        
        log.info(f"Sync complete: {len(self.proxies)} proxies active")


# ============================================================
# DTE Service
# ============================================================

class DTEService:
    """
    DTE side service: sends heartbeat frames
    
    Uses ConfigDBConnector's subscribe/listen pattern to monitor CONFIG_DB changes,
    following SONiC daemon conventions.
    """
    
    def __init__(self, tty_name: str, baud: int):
        self.tty_name = tty_name
        self.baud = baud
        self.device_path = f"/dev/{tty_name}"
        
        self.config_db: Optional[ConfigDBConnector] = None
        
        self.ser_fd: int = -1
        self.running: bool = False
        self.enabled: bool = False
        self.seq: int = 0
        
        self._heartbeat_thread: Optional[threading.Thread] = None
        self._heartbeat_stop: threading.Event = threading.Event()
    
    def start(self) -> bool:
        """Start service"""
        try:
            # Open serial port
            self.ser_fd = os.open(self.device_path, os.O_WRONLY | os.O_NOCTTY | os.O_NONBLOCK)
            
            # Connect to CONFIG_DB (using ConfigDBConnector)
            self.config_db = ConfigDBConnector()
            self.config_db.connect(wait_for_init=True, retry_on=True)
            log.info("ConfigDB connected")
            
            self.running = True
            log.info(f"DTE service initialized: {self.device_path}")
            return True
            
        except Exception as e:
            log.error(f"Failed to start DTE service: {e}")
            return False
    
    def register_callbacks(self) -> None:
        """Register configuration change callbacks"""
        
        def make_callback(func):
            """Create callback wrapper compatible with ConfigDBConnector format"""
            def callback(table, key, data):
                if data is None:
                    op = "DEL"
                    data = {}
                else:
                    op = "SET"
                return func(key, op, data)
            return callback
        
        # Subscribe to CONSOLE_SWITCH table changes
        self.config_db.subscribe(CONSOLE_SWITCH_TABLE,
                                  make_callback(self.console_switch_handler))
        
        log.info("Callbacks registered")
    
    def run(self) -> None:
        """Main loop: use ConfigDBConnector.listen() to monitor configuration changes"""
        try:
            # listen() blocks and invokes registered callbacks when configuration changes
            self.config_db.listen(init_data_handler=self._load_initial_config)
        except KeyboardInterrupt:
            log.info("Received keyboard interrupt")
        except Exception as e:
            if self.running:
                log.error(f"DTE listen error: {e}")
    
    def stop(self) -> None:
        """Stop service"""
        self.running = False
        self._stop_heartbeat()
        
        if self.ser_fd >= 0:
            try:
                os.close(self.ser_fd)
            except:
                pass
            self.ser_fd = -1
        
        log.info("DTE service stopped")
    
    def _load_initial_config(self, init_data: dict) -> None:
        """
        Load initial configuration
        
        Args:
            init_data: Dictionary containing initial data from all subscribed tables
        """
        log.info(f"Loading initial config: {list(init_data.keys())}")
        
        # Check initial enabled state
        self.enabled = self._check_enabled()
        log.info(f"Initial enabled state: {self.enabled}")
        
        # If enabled, start heartbeat thread
        if self.enabled:
            self._start_heartbeat()
    
    def console_switch_handler(self, key: str, op: str, data: dict) -> None:
        """
        CONSOLE_SWITCH table change handler
        
        Args:
            key: Table entry key
            op: Operation type "SET" or "DEL"
            data: Table entry data
        """
        log.info(f"CONSOLE_SWITCH change: key={key}, op={op}, data={data}")
        
        # Check enabled state
        new_enabled = self._check_enabled()
        if new_enabled != self.enabled:
            log.info(f"Enabled state changed: {self.enabled} -> {new_enabled}")
            self.enabled = new_enabled
            
            if self.enabled:
                self._start_heartbeat()
            else:
                self._stop_heartbeat()
    
    def _check_enabled(self) -> bool:
        """Check the enabled field of controlled_device"""
        try:
            entry = self.config_db.get_entry(CONSOLE_SWITCH_TABLE, "controlled_device")
            if entry:
                return entry.get("enabled", "") == "yes"
            return False
        except Exception as e:
            log.warning(f"Failed to check enabled status: {e}")
            return False
    
    def _start_heartbeat(self) -> None:
        """Start heartbeat thread"""
        if self._heartbeat_thread and self._heartbeat_thread.is_alive():
            return
        
        self._heartbeat_stop.clear()
        self._heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self._heartbeat_thread.start()
        log.info("Heartbeat thread started")
    
    def _stop_heartbeat(self) -> None:
        """Stop heartbeat thread"""
        self._heartbeat_stop.set()
        if self._heartbeat_thread and self._heartbeat_thread.is_alive():
            self._heartbeat_thread.join(timeout=2.0)
        self._heartbeat_thread = None
        log.info("Heartbeat thread stopped")
    
    def _heartbeat_loop(self) -> None:
        """Heartbeat send loop"""
        while not self._heartbeat_stop.is_set():
            self._send_heartbeat()
            self._heartbeat_stop.wait(HEARTBEAT_INTERVAL)
    
    def _send_heartbeat(self) -> None:
        """Send heartbeat frame"""
        if self.ser_fd < 0:
            return
        
        frame = Frame.create_heartbeat(self.seq)
        frame_bytes = frame.build()
        
        try:
            os.write(self.ser_fd, frame_bytes)
            log.debug(f"Sent heartbeat (seq={self.seq})")
            log_binary_data(frame_bytes, "DTE→Serial")
            self.seq = (self.seq + 1) % 256
        except Exception as e:
            log.error(f"Failed to send heartbeat: {e}")


# ============================================================
# Main Program Entry
# ============================================================

def signal_handler(signum, frame):
    """Global signal handler"""
    log.info(f"Received signal {signum}")
    raise SystemExit(0)


def run_dce() -> int:
    """DCE service entry point"""
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGHUP, signal_handler)
    
    service = DCEService()
    
    if not service.start():
        return EXIT_SERVICE_START_FAILED
    
    try:
        service.register_callbacks()
        service.run()
    except SystemExit:
        pass
    finally:
        service.stop()
    
    return EXIT_SUCCESS


def run_dte() -> int:
    """DTE service entry point"""
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGHUP, signal_handler)
    
    parser = argparse.ArgumentParser(description='Console Monitor DTE Service')
    parser.add_argument('tty_name', nargs='?', default=None, help='TTY device name')
    parser.add_argument('baud', nargs='?', type=int, default=None, help='Baud rate')
    args = parser.parse_args()
    
    # Determine TTY and baud rate
    if args.tty_name:
        tty_name = args.tty_name
        baud = args.baud if args.baud else DEFAULT_BAUD
        log.info(f"Using command line args: tty={tty_name}, baud={baud}")
    else:
        try:
            tty_name, baud = parse_proc_cmdline()
        except ValueError as e:
            log.error(f"Failed to get serial config: {e}")
            return EXIT_SERIAL_CONFIG_ERROR
    
    service = DTEService(tty_name, baud)
    
    if not service.start():
        return EXIT_SERVICE_START_FAILED
    
    try:
        service.register_callbacks()
        service.run()
    except SystemExit:
        pass
    finally:
        service.stop()
    
    return EXIT_SUCCESS


def main():
    """
    Unified entry point: determines run mode based on command line arguments
    
    Usage:
        console-monitor dce    # Run DCE service
        console-monitor dte    # Run DTE service
    """
    if len(sys.argv) < 2:
        print("Usage: console-monitor <dce|dte> [args...]")
        print("  dce: Run DCE (Console Server) service")
        print("  dte: Run DTE (SONiC Switch) service")
        sys.exit(EXIT_INVALID_MODE)
    
    mode = sys.argv[1].lower()
    sys.argv = sys.argv[1:]  # Remove mode argument for subsequent argparse processing
    
    if mode == "dce":
        sys.exit(run_dce())
    elif mode == "dte":
        sys.exit(run_dte())
    else:
        print(f"Unknown mode: {mode}")
        print("Use 'dce' or 'dte'")
        sys.exit(EXIT_INVALID_MODE)


if __name__ == "__main__":
    main()
